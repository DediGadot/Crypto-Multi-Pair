"""
On-Chain Analytics Strategy

Implements a simple rules-based strategy using on-chain features when available.
If real on-chain features are not present, falls back to 'proxy_*' features
generated by the on-chain ingestor for pipeline validation.

Signals:
- STRONG_BUY when undervaluation + capitulation conditions
- STRONG_SELL when euphoria + profit-taking conditions
Otherwise HOLD
"""

from __future__ import annotations

from typing import Any, Dict, List

import pandas as pd
from loguru import logger

from crypto_trader.strategies.base import BaseStrategy, SignalType
from crypto_trader.strategies.registry import register_strategy


@register_strategy
class OnChainAnalytics(BaseStrategy):
    """On-chain rules strategy using MVRV, SOPR, and flow metrics when available."""

    def __init__(self, name: str = "OnChainAnalytics", config: Dict[str, Any] = None):
        """Initialize OnChainAnalytics strategy."""
        super().__init__(name, config)

    def initialize(self, config: Dict[str, Any]) -> None:
        # Thresholds are configurable; defaults chosen conservatively
        self.config = {
            'mvrv_buy': 0.5,       # undervalued if below
            'mvrv_sell': 6.0,      # euphoric if above
            'sopr_buy': 1.0,       # capitulation when below
            'sopr_sell': 1.05,     # profit-taking when above
            'netflow_buy': -5000.0,
            'netflow_sell': 5000.0,
        } | (config or {})
        self._initialized = True

    def get_parameters(self) -> Dict[str, Any]:
        return dict(self.config)

    def get_required_features(self) -> List[str]:
        # Soft requirement: we'll try real names first, proxies if missing
        return [
            'onchain.mvrv_z', 'onchain.sopr', 'onchain.exchange_netflow'
        ]

    def _choose_col(self, df: pd.DataFrame, real: str, proxy: str) -> str | None:
        if real in df.columns:
            return real
        if proxy in df.columns:
            return proxy
        return None

    def generate_signals(self, data: pd.DataFrame) -> pd.DataFrame:
        if not self._initialized:
            raise ValueError("Strategy not initialized")

        df = data.copy()
        ts = df['timestamp'] if 'timestamp' in df.columns else df.index

        mvrv_col = self._choose_col(df, 'onchain.mvrv_z', 'proxy_mvrv_z')
        sopr_col = self._choose_col(df, 'onchain.sopr', 'proxy_sopr')
        flow_col = self._choose_col(df, 'onchain.exchange_netflow', 'proxy_exchange_netflow')

        # Default to HOLD
        signals = pd.DataFrame({
            'timestamp': ts,
            'signal': SignalType.HOLD.value,
            'confidence': 0.0,
            'metadata': [{} for _ in range(len(df))],
        })

        if mvrv_col is None or sopr_col is None or flow_col is None:
            logger.warning("OnChainAnalytics: missing features; emitting HOLD only")
            return signals

        mvrv = df[mvrv_col].astype(float)
        sopr = df[sopr_col].astype(float)
        netflow = df[flow_col].astype(float)

        buy_mask = (
            (mvrv < float(self.config['mvrv_buy'])) &
            (sopr < float(self.config['sopr_buy'])) &
            (netflow < float(self.config['netflow_buy']))
        )

        sell_mask = (
            (mvrv > float(self.config['mvrv_sell'])) &
            (sopr > float(self.config['sopr_sell'])) &
            (netflow > float(self.config['netflow_sell']))
        )

        signals.loc[buy_mask, 'signal'] = SignalType.BUY.value
        signals.loc[buy_mask, 'confidence'] = 0.8
        signals.loc[sell_mask, 'signal'] = SignalType.SELL.value
        signals.loc[sell_mask, 'confidence'] = 0.8

        # Metadata hints for analysis
        signals.loc[buy_mask, 'metadata'] = [{
            'reason': 'onchain_strong_buy',
            'mvrv': float(self.config['mvrv_buy']),
            'sopr': float(self.config['sopr_buy']),
            'netflow': float(self.config['netflow_buy']),
        }] * int(buy_mask.sum())
        signals.loc[sell_mask, 'metadata'] = [{
            'reason': 'onchain_strong_sell',
            'mvrv': float(self.config['mvrv_sell']),
            'sopr': float(self.config['sopr_sell']),
            'netflow': float(self.config['netflow_sell']),
        }] * int(sell_mask.sum())

        return signals

